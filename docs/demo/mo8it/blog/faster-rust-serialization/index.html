<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">

        <title>Faster Rust Serialization</title>

        <meta name="description"
              content="How to speed up serialization in Rust by more than 2x">

        <link rel="icon"
              type="image/x-icon"
              href="https://salif.github.io/zola-themes-collection/demo/mo8it/images/logo.svg?v=1735128461">

        <link href="https://salif.github.io/zola-themes-collection/demo/mo8it/main.css?v=1735128461"
              rel="stylesheet">

        <link rel="alternate"
              type="application/atom+xml"
              title="Blog | mo8it.com"
              href="https://salif.github.io/zola-themes-collection/demo/mo8it/atom.xml">

        <meta property="og:title" content="Faster Rust Serialization">
        <meta property="og:description" content="How to speed up serialization in Rust by more than 2x">
        <meta property="og:image"
              content="https://salif.github.io/zola-themes-collection/demo/mo8it/images/logo.svg?v=1735128461">
        <meta property="og:url" content="https://salif.github.io/zola-themes-collection/demo/mo8it/blog/faster-rust-serialization/">
    </head>

    <body class="flex flex-col p-3 mx-auto min-h-screen text-lg text-gray-100 break-words bg-gray-900 lg:px-5 2xl:container">
        <header class="flex gap-x-6 items-center py-2 px-2.5 mb-1 bg-gray-800 rounded-full">
            <a class="transition duration-500 hover:scale-110"
               href="https://salif.github.io/zola-themes-collection/demo/mo8it"
               aria-hidden="true">
                <img class="m-0 w-12 h-12 rounded-full"
                     src="https://salif.github.io/zola-themes-collection/demo/mo8it/images/logo.svg"
                     alt="">
            </a>

            <nav class="flex gap-x-5 items-center font-bold">
                
                    <a class="p-1 no-underline" href="/">Home</a>
                
                    <a class="p-1 no-underline" href="/blog">Blog</a>
                
                    <a class="p-1 no-underline" href="/tags">Tags</a>
                
            </nav>
        </header>

        <main class="leading-relaxed">
            
    <article>
        <div class="mb-3">
            <h1>Faster Rust Serialization</h1>

            
    <div class="mt-2 mb-4 text-sm leading-normal text-gray-300">
        <time datetime="2023-10-25">2023-10-25</time><time datetime="2023-10-26">, updated: 2023-10-26</time><p class="my-0">
            Tags:
            <a href="https://salif.github.io/zola-themes-collection/demo/mo8it/tags/rust">#rust</a></p>

        <p class="my-0">Reading time: ~12min</p>

        <hr class="my-2.5">
    </div>

        </div>

        <p>The tech industry happily wastes a lot of resources on serializing and deserializing JSON with its inefficient plain text format.
But sadly, JSON is currently (still) the standard for sending data over the internet.</p>
<p>Nevertheless, we can at least try to make serialization and deserialization as efficient as possible!</p>
<p>In this blog post, we will see how you can improve the serialization performance of <a href="https://docs.rs/serde/latest/serde/"><code>serde</code></a> in Rust.
We will take a look at a simple example and improve its performance by up to <strong>2.25x</strong> ðŸš€</p>
<span id="continue-reading"></span><h4 id="disclaimer"><a class="text-white no-underline transition-none hover:underline"
   href="#disclaimer">Disclaimer</a></h4>
<p>The second part about formatters in this blog post is not for Rust beginners.</p>
<p>If you are just starting with Rust, don't confuse yourself with the details in this post.
Just use <code>serde</code> with the derive macro and you will get very decent performance without further efforts.
You are already wasting much less resources by using Rust instead of a language like Python or Javascript ðŸ˜‰</p>
<p>The basics of the following concepts are required:</p>
<ul>
<li>Iterators</li>
<li>Traits</li>
<li>Generics</li>
<li>Lifetimes</li>
</ul>

    <p class="p-1 my-4 text-base rounded sm:hidden bg-yellow-200/20">Landscape mode recommended on mobile devices</p>

    
        <div class="px-4 pt-3 pb-0.5 mt-3 mb-1 bg-gray-800 rounded">
            <p class="text-2xl font-bold">Contents</p>

            <nav>
                <ul class="ml-0 list-none">
                    
                        
                    
                        
                            <li><a href="https://salif.github.io/zola-themes-collection/demo/mo8it/blog/faster-rust-serialization/#the-problem">The problem</a></li>
                        
                    
                        
                            <li><a href="https://salif.github.io/zola-themes-collection/demo/mo8it/blog/faster-rust-serialization/#implementing-serialize">Implementing Serialize</a></li>
                        
                    
                        
                            <li><a href="https://salif.github.io/zola-themes-collection/demo/mo8it/blog/faster-rust-serialization/#get-used-to-it">Get used to it</a></li>
                        
                    
                        
                            <li><a href="https://salif.github.io/zola-themes-collection/demo/mo8it/blog/faster-rust-serialization/#formatters">Formatters</a></li>
                        
                    
                        
                            <li><a href="https://salif.github.io/zola-themes-collection/demo/mo8it/blog/faster-rust-serialization/#sequence-formatters">Sequence formatters</a></li>
                        
                    
                        
                            <li><a href="https://salif.github.io/zola-themes-collection/demo/mo8it/blog/faster-rust-serialization/#when-to-use-formatters">When to use formatters</a></li>
                        
                    
                        
                            <li><a href="https://salif.github.io/zola-themes-collection/demo/mo8it/blog/faster-rust-serialization/#outlook">Outlook</a></li>
                        
                    
                        
                            <li><a href="https://salif.github.io/zola-themes-collection/demo/mo8it/blog/faster-rust-serialization/#conclusion">Conclusion</a></li>
                        
                    
                        
                            <li><a href="https://salif.github.io/zola-themes-collection/demo/mo8it/blog/faster-rust-serialization/#appendix">Appendix</a>
                                    <ul class="my-0 ml-5 list-none">
                                        
                                            
                                                <li><a class="text-base" href="https://salif.github.io/zola-themes-collection/demo/mo8it/blog/faster-rust-serialization/#benchmarking-strategy">Benchmarking strategy</a></li>
                                            
                                        
                                    </ul>
                                </li>
                        
                    
                </ul>
            </nav>
        </div>
    

<h2 id="the-problem"><a class="text-white no-underline transition-none hover:underline"
   href="#the-problem">The problem</a></h2>
<p>For our example, let's assume we have this struct:</p>
<pre data-lang="rust" style="background-color:#212733;color:#ccc9c2;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#ffa759;">struct </span><span style="color:#73d0ff;">Name </span><span>{
</span><span>    first_name</span><span style="color:#ccc9c2cc;">:</span><span> String,
</span><span>    last_name</span><span style="color:#ccc9c2cc;">:</span><span> String,
</span><span>}
</span></code></pre>
<p>We want to use the full name representation when formatting it (first and last name separated by a whitespace).
Let's implement the <code>Display</code> trait to define that representation:</p>
<pre data-lang="rust" style="background-color:#212733;color:#ccc9c2;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#ffa759;">use </span><span>std</span><span style="color:#f29e74;">::</span><span>fmt</span><span style="color:#f29e74;">::</span><span>{</span><span style="font-style:italic;color:#5ccfe6;">self</span><span style="color:#ccc9c2cc;">,</span><span> Display}</span><span style="color:#ccc9c2cc;">;
</span><span>
</span><span style="color:#ffa759;">impl </span><span>Display </span><span style="color:#ffa759;">for </span><span style="color:#73d0ff;">Name </span><span>{
</span><span>    </span><span style="color:#ffa759;">fn </span><span style="color:#ffd580;">fmt</span><span>(</span><span style="color:#f29e74;">&amp;</span><span style="color:#ffcc66;">self</span><span>, </span><span style="color:#ffcc66;">f</span><span style="color:#ccc9c2cc;">: </span><span style="color:#f29e74;">&amp;</span><span style="color:#ffa759;">mut </span><span>fmt</span><span style="color:#f29e74;">::</span><span>Formatter&lt;&#39;</span><span style="color:#f29e74;">_</span><span>&gt;) </span><span style="color:#ccc9c2cc;">-&gt; </span><span>fmt</span><span style="color:#f29e74;">::</span><span>Result {
</span><span>        </span><span style="color:#f28779;">write!</span><span>(f, </span><span style="color:#bae67e;">&quot;</span><span style="color:#ffcc66;">{} {}</span><span style="color:#bae67e;">&quot;</span><span style="color:#ccc9c2cc;">, </span><span style="font-style:italic;color:#5ccfe6;">self</span><span style="color:#f29e74;">.</span><span>first_name</span><span style="color:#ccc9c2cc;">, </span><span style="font-style:italic;color:#5ccfe6;">self</span><span style="color:#f29e74;">.</span><span>last_name)
</span><span>    }
</span><span>}
</span></code></pre>
<p>This implementation allows us to use <code>println!</code> for example to print instances of this struct:</p>
<pre data-lang="rust" style="background-color:#212733;color:#ccc9c2;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#ffa759;">let</span><span> name </span><span style="color:#f29e74;">=</span><span> Name {
</span><span>    first_name</span><span style="color:#ccc9c2cc;">: </span><span style="color:#bae67e;">&quot;Max&quot;</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">to_string</span><span>()</span><span style="color:#ccc9c2cc;">,
</span><span>    last_name</span><span style="color:#ccc9c2cc;">: </span><span style="color:#bae67e;">&quot;Mustermann&quot;</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">to_string</span><span>()</span><span style="color:#ccc9c2cc;">,
</span><span>}</span><span style="color:#ccc9c2cc;">;
</span><span>
</span><span style="color:#f28779;">println!</span><span>(</span><span style="color:#bae67e;">&quot;Hello </span><span style="color:#ffcc66;">{name}</span><span style="color:#bae67e;">&quot;</span><span>)</span><span style="color:#ccc9c2cc;">;
</span><span style="font-style:italic;color:#5c6773;">// Output: Hello Max Mustermann
</span></code></pre>
<p>Let's assume that we have a vector or slice of <code>Name</code> as input (e.g. result of a database query).
Our task is to serialize it to a JSON vector of full names.</p>
<p>Pause reading and think about it for a minute.
How would you achieve that goal?</p>
<p>The naive way would be to convert the names to full name strings and then serialize them:</p>
<pre data-lang="rust" style="background-color:#212733;color:#ccc9c2;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#ffa759;">fn </span><span style="color:#ffd580;">naive</span><span>(</span><span style="color:#ffcc66;">names</span><span style="color:#ccc9c2cc;">: </span><span style="color:#f29e74;">&amp;</span><span>[Name]) </span><span style="color:#ccc9c2cc;">-&gt; </span><span>serde_json</span><span style="color:#f29e74;">::</span><span style="font-style:italic;color:#5ccfe6;">Result</span><span>&lt;</span><span style="font-style:italic;color:#5ccfe6;">String</span><span>&gt; {
</span><span>    </span><span style="color:#ffa759;">let</span><span> full_names </span><span style="color:#f29e74;">=</span><span> names
</span><span>        </span><span style="color:#f29e74;">.</span><span style="color:#f28779;">iter</span><span>()
</span><span>        </span><span style="color:#f29e74;">.</span><span style="color:#f28779;">map</span><span>(|</span><span style="color:#ffcc66;">name</span><span>| name</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">to_string</span><span>())
</span><span>        </span><span style="color:#f29e74;">.</span><span>collect</span><span style="color:#f29e74;">::</span><span>&lt;</span><span style="font-style:italic;color:#5ccfe6;">Vec</span><span>&lt;</span><span style="color:#f29e74;">_</span><span>&gt;&gt;()</span><span style="color:#ccc9c2cc;">;
</span><span>
</span><span>    serde_json</span><span style="color:#f29e74;">::</span><span>to_string(</span><span style="color:#f29e74;">&amp;</span><span>full_names)
</span><span>}
</span></code></pre>
<p>We iterate over the input slice and map <code>Name</code> to its <code>Display</code> string representation using the <a href="https://doc.rust-lang.org/stable/std/string/trait.ToString.html"><code>to_string()</code></a> method.
Then, we collect our goal vector of full names and serialize it.</p>
<p>Straightforward, right?</p>
<p>The problem is that we are making an allocation for each name!
The <code>to_string()</code> method returns a <code>String</code> which has to be allocated on the heap.
Heap allocations are expensive!</p>
<p>"But our serialized output is supposed to be a vector of strings!", you might say.</p>
<p>Yes, but this doesn't mean that we have to create that strings <strong>before</strong> the serialization.
We can create them <strong>during</strong> the serialization and directly append them to the serializer's buffer instead of allocating our own buffers first.
But how?</p>
<h2 id="implementing-serialize"><a class="text-white no-underline transition-none hover:underline"
   href="#implementing-serialize">Implementing <code>Serialize</code></a></h2>
<p>A serde serializer can serialize a type that implements the serde trait <a href="https://docs.rs/serde/1.0.189/serde/trait.Serialize.html"><code>Serialize</code></a> (check the signature of <a href="https://docs.rs/serde_json/1.0.107/serde_json/fn.to_string.html"><code>serde_json::to_string</code></a> for example).
<code>Serialize</code> is implemented on <code>Vec&lt;T&gt;</code> or <code>[T]</code> if <code>T</code> itself implements <code>Serialize</code>.
Therefore, to directly serialize our input slice, <code>Name</code> must implement <code>Serialize</code>.</p>
<p>We could derive the default implementation of <code>Serialize</code> for <code>Name</code> by adding <code>#[derive(Serialize)]</code> above the struct.
But the derived default implementation would serialize an instance to the following JSON object:</p>
<pre data-lang="json" style="background-color:#212733;color:#ccc9c2;" class="language-json "><code class="language-json" data-lang="json"><span>{ </span><span style="color:#bae67e;">&quot;first_name&quot;</span><span style="color:#ccc9c2cc;">: </span><span style="color:#bae67e;">&quot;Max&quot;</span><span style="color:#ccc9c2cc;">, </span><span style="color:#bae67e;">&quot;last_name&quot;</span><span style="color:#ccc9c2cc;">: </span><span style="color:#bae67e;">&quot;Mustermann&quot; </span><span>}
</span></code></pre>
<p>But we actually want a serialization to the following string:</p>
<pre data-lang="json" style="background-color:#212733;color:#ccc9c2;" class="language-json "><code class="language-json" data-lang="json"><span style="color:#bae67e;">&quot;Max Mustermann&quot;
</span></code></pre>
<p>This means that we have to manually implement the <code>Serialize</code> trait:</p>
<pre data-lang="rust" style="background-color:#212733;color:#ccc9c2;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#ffa759;">use </span><span>serde</span><span style="color:#f29e74;">::</span><span>{Serialize</span><span style="color:#ccc9c2cc;">,</span><span> Serializer}</span><span style="color:#ccc9c2cc;">;
</span><span>
</span><span style="color:#ffa759;">impl </span><span>Serialize </span><span style="color:#ffa759;">for </span><span style="color:#73d0ff;">Name </span><span>{
</span><span>    </span><span style="color:#ffa759;">fn </span><span style="color:#ffd580;">serialize</span><span>&lt;S&gt;(</span><span style="color:#f29e74;">&amp;</span><span style="color:#ffcc66;">self</span><span>, </span><span style="color:#ffcc66;">serializer</span><span style="color:#ccc9c2cc;">:</span><span> S) </span><span style="color:#ccc9c2cc;">-&gt; </span><span style="font-style:italic;color:#5ccfe6;">Result</span><span>&lt;</span><span style="color:#ffa759;">S</span><span style="color:#f29e74;">::</span><span style="font-style:italic;color:#5ccfe6;">Ok</span><span>, </span><span style="color:#ffa759;">S</span><span style="color:#f29e74;">::</span><span>Error&gt;
</span><span>    </span><span style="color:#ffa759;">where
</span><span>        S</span><span style="color:#ccc9c2cc;">:</span><span> Serializer,
</span><span>    {
</span><span>        serializer</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">collect_str</span><span>(</span><span style="color:#f29e74;">&amp;</span><span style="font-style:italic;color:#5ccfe6;">self</span><span>)
</span><span>    }
</span><span>}
</span></code></pre>
<p>We tell the serializer to "collect" a string from our instance.
<a href="https://docs.rs/serde/1.0.189/serde/trait.Serializer.html"><code>collect_str</code></a> takes an argument <code>&amp;T</code> where <code>T</code> implements <code>Display</code> and appends that <code>Display</code> string representation to the serializer.</p>
<p>We just built a bridge between the <code>Display</code> and <code>Serialize</code> trait ðŸŒ‰</p>
<p>Now that our type implements <code>Serialize</code>, we can just directly pass its slice to the serializer:</p>
<pre data-lang="rust" style="background-color:#212733;color:#ccc9c2;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#ffa759;">fn </span><span style="color:#ffd580;">manual_serialize</span><span>(</span><span style="color:#ffcc66;">names</span><span style="color:#ccc9c2cc;">: </span><span style="color:#f29e74;">&amp;</span><span>[Name]) </span><span style="color:#ccc9c2cc;">-&gt; </span><span>serde_json</span><span style="color:#f29e74;">::</span><span style="font-style:italic;color:#5ccfe6;">Result</span><span>&lt;</span><span style="font-style:italic;color:#5ccfe6;">String</span><span>&gt; {
</span><span>    serde_json</span><span style="color:#f29e74;">::</span><span>to_string(names)
</span><span>}
</span></code></pre>
<p>Let's benchmark both methods!</p>
<p>The following line chart shows the ratio of the time that <code>naive</code> takes to serialize <code>N</code> names in comparison with <code>manual_serialize</code>:</p>
<p><img src="https://salif.github.io/zola-themes-collection/demo/mo8it/blog/faster-rust-serialization/speedup.svg" alt="The speedup from the benchmark results" /></p>
<p>We get a speedup between 1.25x and <strong>2.25x</strong> ðŸš€</p>
<p>The speedup depends on the number of names <code>N</code>.
There is a tendency of higher speedups for higher <code>N</code> values.</p>
<p>All what we did to get this speedup is implementing the <code>Serialize</code> trait using one line for the body of the <code>serialize</code> method!</p>
<div class="rounded-xl bg-sky-400/20">
    <div class="px-2 pt-2 pb-1 my-3 text-white">
        <p class="font-bold">Note</p>
        <p>I used the new benchmarking crate <a href="https://docs.rs/divan/latest/divan/"><code>divan</code></a> for the benchmarks and Julia for plotting.
You can find the full benchmark code <a href="https://codeberg.org/mo8it/blog_demos/src/branch/main/faster-rust-serialization/benches/serialization.rs">here</a>.</p>
<p>We should of course test that both functions return the same output!
You can find the test <a href="https://codeberg.org/mo8it/blog_demos/src/branch/main/faster-rust-serialization/tests/equality.rs">here</a>.</p>
<p>The test passes, trust me ðŸ˜‡</p>

    </div>
</div>
<h2 id="get-used-to-it"><a class="text-white no-underline transition-none hover:underline"
   href="#get-used-to-it">Get used to it</a></h2>
<p>You could use the crate <a href="https://docs.rs/serde_with/latest/serde_with/"><code>serde_with</code></a> to implement the bridge between <code>Display</code> and <code>Serialize</code> with a macro.
But manually implementing the <code>Serialize</code> trait is much more flexible if you want to do more than this bridging.
<code>Serialize</code> is a tiny but very powerful trait that you should get used to.</p>
<p>Yes, the signature of the single trait method is rather long.
But you are not forced to manually type it!
Just write the following and your editor will suggest autocompleting the signature after typing <code>fn</code>:</p>
<pre data-lang="rust" style="background-color:#212733;color:#ccc9c2;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#ffa759;">impl </span><span>Serialize </span><span style="color:#ffa759;">for </span><span style="color:#73d0ff;">TYPENAME </span><span>{
</span><span>    </span><span style="color:#ffa759;">fn </span><span style="font-style:italic;color:#5c6773;">// &lt;- Autocompletion on your cursor here
</span><span>}
</span></code></pre>
<p>After autocompletion:</p>
<pre data-lang="rust" style="background-color:#212733;color:#ccc9c2;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#ffa759;">impl </span><span>Serialize </span><span style="color:#ffa759;">for </span><span style="color:#73d0ff;">TYPENAME </span><span>{
</span><span>    </span><span style="color:#ffa759;">fn </span><span style="color:#ffd580;">serialize</span><span>&lt;S&gt;(</span><span style="color:#f29e74;">&amp;</span><span style="color:#ffcc66;">self</span><span>, </span><span style="color:#ffcc66;">serializer</span><span style="color:#ccc9c2cc;">:</span><span> S) </span><span style="color:#ccc9c2cc;">-&gt; </span><span style="font-style:italic;color:#5ccfe6;">Result</span><span>&lt;</span><span style="color:#ffa759;">S</span><span style="color:#f29e74;">::</span><span style="font-style:italic;color:#5ccfe6;">Ok</span><span>, </span><span style="color:#ffa759;">S</span><span style="color:#f29e74;">::</span><span>Error&gt;
</span><span>    </span><span style="color:#ffa759;">where
</span><span>        S</span><span style="color:#ccc9c2cc;">:</span><span> Serializer,
</span><span>    {
</span><span>        </span><span style="font-style:italic;color:#5c6773;">// &lt;- Cursor after autocompletion
</span><span>    }
</span><span>}
</span></code></pre>
<div class="rounded-xl bg-sky-400/20">
    <div class="px-2 pt-2 pb-1 my-3 text-white">
        <p class="font-bold">Note</p>
        <p>Your editor needs to have LSP (language server protocol) support to apply that autocompletion from <a href="https://rust-analyzer.github.io/">rust-analyzer</a>.</p>

    </div>
</div>
<h2 id="formatters"><a class="text-white no-underline transition-none hover:underline"
   href="#formatters">Formatters</a></h2>
<p>By directly implementing <code>Serialize</code> manually on our type <code>Name</code>, we lost the ability to have the default derived implementation.
You are out of luck if you need to send the following JSON object representation later in another context:</p>
<pre data-lang="json" style="background-color:#212733;color:#ccc9c2;" class="language-json "><code class="language-json" data-lang="json"><span>{ </span><span style="color:#bae67e;">&quot;first_name&quot;</span><span style="color:#ccc9c2cc;">: </span><span style="color:#bae67e;">&quot;Max&quot;</span><span style="color:#ccc9c2cc;">, </span><span style="color:#bae67e;">&quot;last_name&quot;</span><span style="color:#ccc9c2cc;">: </span><span style="color:#bae67e;">&quot;Mustermann&quot; </span><span>}
</span></code></pre>
<p>Therefore, I would recommend to not manually implement the <code>Serialize</code> trait directly on your data types.
Instead, you should implement it on wrapper types that act like <em>formatters</em>.</p>
<p>Here is an example:</p>
<pre data-lang="rust" style="background-color:#212733;color:#ccc9c2;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#ffa759;">struct </span><span style="color:#73d0ff;">DisplayFormatter</span><span>&lt;T</span><span style="color:#ccc9c2cc;">:</span><span> Display&gt;(T)</span><span style="color:#ccc9c2cc;">;
</span><span>
</span><span style="color:#ffa759;">impl</span><span>&lt;T</span><span style="color:#ccc9c2cc;">:</span><span> Display&gt; Serialize </span><span style="color:#ffa759;">for </span><span style="color:#73d0ff;">DisplayFormatter</span><span>&lt;T&gt; {
</span><span>    </span><span style="color:#ffa759;">fn </span><span style="color:#ffd580;">serialize</span><span>&lt;S&gt;(</span><span style="color:#f29e74;">&amp;</span><span style="color:#ffcc66;">self</span><span>, </span><span style="color:#ffcc66;">serializer</span><span style="color:#ccc9c2cc;">:</span><span> S) </span><span style="color:#ccc9c2cc;">-&gt; </span><span style="font-style:italic;color:#5ccfe6;">Result</span><span>&lt;</span><span style="color:#ffa759;">S</span><span style="color:#f29e74;">::</span><span style="font-style:italic;color:#5ccfe6;">Ok</span><span>, </span><span style="color:#ffa759;">S</span><span style="color:#f29e74;">::</span><span>Error&gt;
</span><span>    </span><span style="color:#ffa759;">where
</span><span>        S</span><span style="color:#ccc9c2cc;">:</span><span> Serializer,
</span><span>    {
</span><span>        serializer</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">collect_str</span><span>(</span><span style="color:#f29e74;">&amp;</span><span style="font-style:italic;color:#5ccfe6;">self</span><span style="color:#f29e74;">.</span><span style="color:#ffcc66;">0</span><span>)
</span><span>    }
</span><span>}
</span></code></pre>
<p>This generic formatter takes a type that implements <code>Display</code> and serializes it using that representation.
You can use it not only on our <code>Name</code> type, but on any type that implements <code>Display</code>.</p>
<p>But your type doesn't always have to implement <code>Display</code>!
Or maybe you want to have different implementations for <code>Display</code> and <code>Serialize</code>.
In that case, you can use such a concrete formatter instead:</p>
<pre data-lang="rust" style="background-color:#212733;color:#ccc9c2;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#ffa759;">struct </span><span style="color:#73d0ff;">FullNameFormatter</span><span>&lt;</span><span style="color:#ffa759;">&#39;a</span><span>&gt;(</span><span style="color:#f29e74;">&amp;</span><span style="color:#ffa759;">&#39;a</span><span> Name)</span><span style="color:#ccc9c2cc;">;
</span><span>
</span><span style="color:#ffa759;">impl</span><span>&lt;</span><span style="color:#ffa759;">&#39;a</span><span>&gt; Serialize </span><span style="color:#ffa759;">for </span><span style="color:#73d0ff;">FullNameFormatter</span><span>&lt;</span><span style="color:#ffa759;">&#39;a</span><span>&gt; {
</span><span>    </span><span style="color:#ffa759;">fn </span><span style="color:#ffd580;">serialize</span><span>&lt;S&gt;(</span><span style="color:#f29e74;">&amp;</span><span style="color:#ffcc66;">self</span><span>, </span><span style="color:#ffcc66;">serializer</span><span style="color:#ccc9c2cc;">:</span><span> S) </span><span style="color:#ccc9c2cc;">-&gt; </span><span style="font-style:italic;color:#5ccfe6;">Result</span><span>&lt;</span><span style="color:#ffa759;">S</span><span style="color:#f29e74;">::</span><span style="font-style:italic;color:#5ccfe6;">Ok</span><span>, </span><span style="color:#ffa759;">S</span><span style="color:#f29e74;">::</span><span>Error&gt;
</span><span>    </span><span style="color:#ffa759;">where
</span><span>        S</span><span style="color:#ccc9c2cc;">:</span><span> Serializer,
</span><span>    {
</span><span>        serializer</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">collect_str</span><span>(</span><span style="color:#f29e74;">&amp;</span><span style="color:#f28779;">format_args!</span><span>(</span><span style="color:#bae67e;">&quot;{} {}&quot;</span><span style="color:#ccc9c2cc;">, </span><span style="font-style:italic;color:#5ccfe6;">self</span><span style="color:#f29e74;">.</span><span style="color:#ffcc66;">0.</span><span>first_name</span><span style="color:#ccc9c2cc;">, </span><span style="font-style:italic;color:#5ccfe6;">self</span><span style="color:#f29e74;">.</span><span style="color:#ffcc66;">0.</span><span>last_name))
</span><span>    }
</span><span>}
</span></code></pre>
<p>Here, we directly use <code>format_args!</code> which is what all formatting macros like <code>println!</code> and <code>format!</code> use under the hood.
But <code>format_args!</code> doesn't allocate or even apply the formatting!
It only returns <a href="https://doc.rust-lang.org/stable/std/fmt/struct.Arguments.html"><code>Arguments</code></a> which is a formatter that borrows its arguments.
The important thing is that <code>Arguments</code> implements <code>Display</code> which we need for the <code>collect_str()</code> method.</p>
<p>Now, we can use that formatter when we want to serialize the full name:</p>
<pre data-lang="rust" style="background-color:#212733;color:#ccc9c2;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#ffa759;">fn </span><span style="color:#ffd580;">formatter</span><span>(</span><span style="color:#ffcc66;">names</span><span style="color:#ccc9c2cc;">: </span><span style="color:#f29e74;">&amp;</span><span>[Name]) </span><span style="color:#ccc9c2cc;">-&gt; </span><span>serde_json</span><span style="color:#f29e74;">::</span><span style="font-style:italic;color:#5ccfe6;">Result</span><span>&lt;</span><span style="font-style:italic;color:#5ccfe6;">String</span><span>&gt; {
</span><span>    </span><span style="color:#ffa759;">let</span><span> full_names </span><span style="color:#f29e74;">=</span><span> names</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">iter</span><span>()</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">map</span><span>(FullNameFormatter)</span><span style="color:#f29e74;">.</span><span>collect</span><span style="color:#f29e74;">::</span><span>&lt;</span><span style="font-style:italic;color:#5ccfe6;">Vec</span><span>&lt;</span><span style="color:#f29e74;">_</span><span>&gt;&gt;()</span><span style="color:#ccc9c2cc;">;
</span><span>
</span><span>    serde_json</span><span style="color:#f29e74;">::</span><span>to_string(</span><span style="color:#f29e74;">&amp;</span><span>full_names)
</span><span>}
</span></code></pre>
<p>We map each <code>&amp;Name</code> to <code>FullNameFormatter(&amp;Name)</code> and collect the map into a vector which is then passed to the serializer.</p>
<p>Check out the benchmark results in the chart below to see that this method has almost the same performance as the one before:</p>
<p><img src="https://salif.github.io/zola-themes-collection/demo/mo8it/blog/faster-rust-serialization/time.svg" alt="The time of every method from the benchmark results" /></p>
<p>There is no real performance difference because wrapper types are a zero cost abstraction in Rust.</p>
<p>But actually, there should be an additional cost not related to the wrapper type itself.
If you zoom into the chart above, you should see that this method has slightly worse performance than <code>manual_serialize</code> for low <code>N</code> values ðŸ˜±</p>
<p>It is the allocation of collecting the map into a <code>Vec</code>!</p>
<p>This allocation barely shows up in the benchmark results, especially for higher <code>N</code> values.
This is because it is done only once and its overhead is neglectable in comparison with the serialization itself.</p>
<p>Although it seems like an unneeded optimization, we will eliminate that allocation, at least to see one more example of formatters.</p>
<h2 id="sequence-formatters"><a class="text-white no-underline transition-none hover:underline"
   href="#sequence-formatters">Sequence formatters</a></h2>
<p>We can't just skip collecting the map and pass the iterator to the serializer because serde <a href="https://github.com/serde-rs/serde/issues/571">doesn't directly support serialization of iterators</a>.
The <code>Serialize</code> trait is not implemented for iterators, but a serde <a href="https://docs.rs/serde/1.0.189/serde/trait.Serializer.html"><code>Serializer</code></a> provides the method <a href="https://docs.rs/serde/1.0.189/serde/trait.Serializer.html#method.collect_seq"><code>collect_seq</code></a> for collecting iterators.</p>
<p>We need a wrapper type that takes our slice and serializes it by passing the map to <code>collect_seq</code>:</p>
<pre data-lang="rust" style="background-color:#212733;color:#ccc9c2;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#ffa759;">struct </span><span style="color:#73d0ff;">FullNameSequenceFormatter</span><span>&lt;</span><span style="color:#ffa759;">&#39;a</span><span>&gt;(</span><span style="color:#f29e74;">&amp;</span><span style="color:#ffa759;">&#39;a</span><span> [Name])</span><span style="color:#ccc9c2cc;">;
</span><span>
</span><span style="color:#ffa759;">impl</span><span>&lt;</span><span style="color:#ffa759;">&#39;a</span><span>&gt; Serialize </span><span style="color:#ffa759;">for </span><span style="color:#73d0ff;">FullNameSequenceFormatter</span><span>&lt;</span><span style="color:#ffa759;">&#39;a</span><span>&gt; {
</span><span>    </span><span style="color:#ffa759;">fn </span><span style="color:#ffd580;">serialize</span><span>&lt;S&gt;(</span><span style="color:#f29e74;">&amp;</span><span style="color:#ffcc66;">self</span><span>, </span><span style="color:#ffcc66;">serializer</span><span style="color:#ccc9c2cc;">:</span><span> S) </span><span style="color:#ccc9c2cc;">-&gt; </span><span style="font-style:italic;color:#5ccfe6;">Result</span><span>&lt;</span><span style="color:#ffa759;">S</span><span style="color:#f29e74;">::</span><span style="font-style:italic;color:#5ccfe6;">Ok</span><span>, </span><span style="color:#ffa759;">S</span><span style="color:#f29e74;">::</span><span>Error&gt;
</span><span>    </span><span style="color:#ffa759;">where
</span><span>        S</span><span style="color:#ccc9c2cc;">:</span><span> Serializer,
</span><span>    {
</span><span>        serializer</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">collect_seq</span><span>(</span><span style="font-style:italic;color:#5ccfe6;">self</span><span style="color:#f29e74;">.</span><span style="color:#ffcc66;">0.</span><span style="color:#f28779;">iter</span><span>()</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">map</span><span>(FullNameFormatter))
</span><span>    }
</span><span>}
</span></code></pre>
<p>We can now just pass our <em>sequence formatter</em> to the serializer:</p>
<pre data-lang="rust" style="background-color:#212733;color:#ccc9c2;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#ffa759;">fn </span><span style="color:#ffd580;">sequence_formatter</span><span>(</span><span style="color:#ffcc66;">names</span><span style="color:#ccc9c2cc;">: </span><span style="color:#f29e74;">&amp;</span><span>[Name]) </span><span style="color:#ccc9c2cc;">-&gt; </span><span>serde_json</span><span style="color:#f29e74;">::</span><span style="font-style:italic;color:#5ccfe6;">Result</span><span>&lt;</span><span style="font-style:italic;color:#5ccfe6;">String</span><span>&gt; {
</span><span>    serde_json</span><span style="color:#f29e74;">::</span><span>to_string(</span><span style="color:#f29e74;">&amp;</span><span>FullNameSequenceFormatter(names))
</span><span>}
</span></code></pre>
<p>You can check the benchmark results above to see that this method has the same performance as <code>manual_serialize</code>.
We went back to a zero cost abstraction without coupling <code>Serialize</code> to <code>Display</code> ðŸŒŸ</p>
<h2 id="when-to-use-formatters"><a class="text-white no-underline transition-none hover:underline"
   href="#when-to-use-formatters">When to use formatters</a></h2>
<p>You might argue that we introduced unneeded complexity to our code by deciding to implement these two formatters.</p>
<p>You are right.
If you are sure that you don't need the default derived implementation of <code>Serialize</code>, then it is much simpler to have a direct manual implementation of <code>Serialize</code> on your type.
But I showed you how to use formatters in this example in case you additionally need the default derived implementation.</p>
<p>But you <em>have to</em> use formatters if you want to manually implement <code>Serialize</code> on <strong>foreign types</strong> (types defined in other crates)!</p>
<p>Even if a foreign type doesn't already implement <code>Serialize</code>, <code>Serialize</code> is a foreign trait and you can't implement foreign traits on foreign types in Rust.
This is because of the <em>potential</em> conflict in case the foreign crate owning either the trait or the type implements that trait on that type.</p>
<p>If you want to implement a trait on a type, either the trait or the type has to be defined in your crate.
Therefore, if you want to define <code>Serialize</code> for <a href="https://docs.rs/time/0.3.30/time/struct.OffsetDateTime.html"><code>OffsetDatetime</code></a> for example, you need to use a wrapper type as a datetime formatter.</p>
<div class="rounded-xl bg-sky-400/20">
    <div class="px-2 pt-2 pb-1 my-3 text-white">
        <p class="font-bold">Note</p>
        <p>This "wrapper type" pattern is also called the <a href="https://rust-unofficial.github.io/patterns/patterns/behavioural/newtype.html">Newtype pattern</a> in the Rust community.</p>

    </div>
</div>
<h2 id="outlook"><a class="text-white no-underline transition-none hover:underline"
   href="#outlook">Outlook</a></h2>
<p>It is worth noting that <em>formatters</em>, as introduced in this post, don't have to be simple wrapper types.
They have to take a reference to the type that we want to format, but they can also take other input that can be used while formatting.</p>
<p>You might have also guessed that these formatter types don't have to be restricted to implementing <code>Serialize</code>.
It would make a lot of sense to implement <code>Display</code> on them when needed.</p>
<p>Our example was rather simple and we only used two of the methods that a serde serializer provides.
Check out the many methods of the <a href="https://docs.rs/serde/latest/serde/trait.Serializer.html"><code>Serializer</code></a> trait for more specific serializations.</p>
<p>Finally, our example used JSON, but the presented content in this blog post can be applied to any serializer with serde support.</p>
<h2 id="conclusion"><a class="text-white no-underline transition-none hover:underline"
   href="#conclusion">Conclusion</a></h2>
<p>"Avoid allocations" is the real conclusion of this blog post.
But to be more specific: Avoid allocating intermediate states of your data before serialization.</p>
<p>We have seen that a simple manual implementation of the <code>Serialize</code> trait can lead to a major performance improvement.</p>
<p>This doesn't mean that you should always implement <code>Serialize</code> manually though!
Only if you want a custom serialization.
Otherwise, just use <code>#[derive(Serialize)]</code> on your type ðŸ˜ƒ</p>
<p>Search for <code>format!</code>, <code>String</code>, <code>to_owned</code>, <code>to_string</code> and <code>collect</code> in your code just before serialization.
If you find any of these allocating pieces, think about whether you can easily avoid them ðŸš€</p>
<hr />
<h2 id="appendix"><a class="text-white no-underline transition-none hover:underline"
   href="#appendix">Appendix</a></h2>
<h3 id="benchmarking-strategy"><a class="text-white no-underline transition-none hover:underline"
   href="#benchmarking-strategy">Benchmarking strategy</a></h3>
<p>It took me a long time to achieve good benchmark results.
The strategy that I ended up with isn't trivial.
Therefore, I wanted to present it in the appendix.</p>
<p>With <em>good</em> results, I mean results without huge fluctuations.
The problem is that the serialization time for low values of <code>N</code> (number of names) varies a lot because it is in the range of nano- and microseconds.
The randomness of the OS and CPU frequency made the benchmark results very inaccurate.</p>
<p>How could we eliminate that randomness?
The answer is easy: Instead of benchmarking one serialization, benchmark multiple iterations.
But there is a huge difference in the required time needed for <code>N = 2^0 = 1</code> and <code>N = 2^20 = 1_048_576</code>!</p>
<p>This means that the number of iterations that we benchmark must depend on <code>N</code>.
We want one iteration for the maximum benchmarked value of <code>N</code> and more iterations the lower the value <code>N</code> becomes.</p>
<div class="rounded-xl bg-sky-400/20">
    <div class="px-2 pt-2 pb-1 my-3 text-white">
        <p class="font-bold">Note</p>
        <p>Although I say that the maximum value of <code>N</code> has only one iteration, these iterations are only one sample in <code>divan</code>.
I used 25 samples for all <code>N</code> values for better statistics.</p>

    </div>
</div>
<p>First, I tried a linear dependency in the exponent with <code>2^(20 - log2(N))</code>.
This formula for the number of iterations leads to only one iteration for the maximum value of <code>N</code> which is <code>2^20</code> in this benchmark.
The problem was that values of <code>N</code> between <code>2^12</code> and <code>2^18</code> took too long.
But the results for low values were good!</p>
<p>Therefore, I needed to use less iterations for that high <code>N</code> values, but I had to keep a high number of iterations for low <code>N</code> values.
This means that I had to try the next dependency in the exponent which is a quadratic one: <code>2^((20 - log2(N))^2 / 20)</code>.
The division through 20 keeps the value for <code>log2(N) = 0</code> unchanged in comparison with the linear dependency.
You can see the shape of both formulas in the chart below:</p>
<p><img src="https://salif.github.io/zola-themes-collection/demo/mo8it/blog/faster-rust-serialization/bench_iterations.svg" alt="A chart showing the number of benchmark iterations over the number of names N" /></p>
<p>Of course, the exponent has to be an integer to get an integer for the number of iterations.
Therefore, the division in the exponent is an integer division and its result is also visualized in the chart above.</p>
<p>This strategy resulted in times in the range of millisconds for all values of <code>N</code> and the huge randomness was eliminated.
Of course, I divided the time through the number of iterations for each <code>N</code> before comparing the serialization performance.</p>
<p>Yes, a lot of heuristics, but I got good, stable results ðŸ˜ƒ</p>
<hr />
<h4 id="full-code"><a class="text-white no-underline transition-none hover:underline"
   href="#full-code">Full code</a></h4>
<p>The full code used in this post can be found <a href="https://codeberg.org/mo8it/blog_demos/src/branch/main/faster-rust-serialization">here</a>.</p>

    </article>

    
        <nav class="flex flex-col gap-y-3 mt-8">
            
    
    <a class="py-1.5 px-3 my-2 no-underline bg-gray-800 rounded-xl transition duration-500 hover:scale-[1.02]"
       href="https://salif.github.io/zola-themes-collection/demo/mo8it/blog/privacy/">Next post: Killing in the name of Privacy<hr class="mt-1 mb-3 rounded-none border-gray-600"><span class="text-white">How an AD blocker killed my work of months and how is this related to telemetry in FOSS</span></a>


            
    
    <a class="py-1.5 px-3 my-2 no-underline bg-gray-800 rounded-xl transition duration-500 hover:scale-[1.02]"
       href="https://salif.github.io/zola-themes-collection/demo/mo8it/blog/teaching-rust/">Previous post: Teaching Rust in 5 days<hr class="mt-1 mb-3 rounded-none border-gray-600"><span class="text-white">Can you learn Rust in 5 days? And how was my experience teaching Rust at my university?</span></a>


        </nav>
    

    <section class="mt-8 text-base text-center">
        <p>
            You can suggest improvements on the <a href="https://codeberg.org/mo8it/website/src/branch/main/content/blog">website's repository</a>
        </p>
        <p>
            Content license: <a href="https://creativecommons.org/licenses/by-nc-sa/4.0">CC BY-NC-SA 4.0</a>
        </p>
    </section>

        </main>

        <footer class="pt-2 pb-3 mt-auto">
            <img class="m-0 mx-auto w-20 h-20"
                 src="https://salif.github.io/zola-themes-collection/demo/mo8it/images/happy_ferris.svg"
                 alt="">

            <nav class="flex flex-col gap-y-3 justify-around py-3 text-center bg-gray-800 rounded sm:flex-row sm:rounded-full">
                
                    <a class="text-sm no-underline" href="/contact">Contact</a>
                
                    <a class="text-sm no-underline" href="https://codeberg.org/mo8it/website">Source Code</a>
                
                    <a class="text-sm no-underline" href="/legal-notice">Legal Notice</a>
                
                    <a class="text-sm no-underline" href="/privacy-policy">Privacy Policy</a>
                
            </nav>
        </footer>

        
            <script type="module" src="https://oxitraffic.mo8it.com/count.js"></script>
        
    </body>
</html>
