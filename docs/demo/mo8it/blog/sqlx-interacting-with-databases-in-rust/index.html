<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">

        <title>SQLx - Interacting with databases in Rust</title>

        <meta name="description"
              content="How to interact with databases in Rust with SQLx">

        <link rel="icon"
              type="image/x-icon"
              href="https://salif.github.io/zola-themes-collection/demo/mo8it/images/logo.svg?v=1733601264">

        <link href="https://salif.github.io/zola-themes-collection/demo/mo8it/main.css?v=1733601264"
              rel="stylesheet">

        <link rel="alternate"
              type="application/atom+xml"
              title="Blog | mo8it.com"
              href="https://salif.github.io/zola-themes-collection/demo/mo8it/atom.xml">

        <meta property="og:title" content="SQLx - Interacting with databases in Rust">
        <meta property="og:description" content="How to interact with databases in Rust with SQLx">
        <meta property="og:image"
              content="https://salif.github.io/zola-themes-collection/demo/mo8it/images/logo.svg?v=1733601264">
        <meta property="og:url" content="https://salif.github.io/zola-themes-collection/demo/mo8it/blog/sqlx-interacting-with-databases-in-rust/">
    </head>

    <body class="flex flex-col p-3 mx-auto min-h-screen text-lg text-gray-100 break-words bg-gray-900 lg:px-5 2xl:container">
        <header class="flex gap-x-6 items-center py-2 px-2.5 mb-1 bg-gray-800 rounded-full">
            <a class="transition duration-500 hover:scale-110"
               href="https://salif.github.io/zola-themes-collection/demo/mo8it"
               aria-hidden="true">
                <img class="m-0 w-12 h-12 rounded-full"
                     src="https://salif.github.io/zola-themes-collection/demo/mo8it/images/logo.svg"
                     alt="">
            </a>

            <nav class="flex gap-x-5 items-center font-bold">
                
                    <a class="p-1 no-underline" href="/">Home</a>
                
                    <a class="p-1 no-underline" href="/blog">Blog</a>
                
                    <a class="p-1 no-underline" href="/tags">Tags</a>
                
            </nav>
        </header>

        <main class="leading-relaxed">
            
    <article>
        <div class="mb-3">
            <h1>SQLx - Interacting with databases in Rust</h1>

            
    <div class="mt-2 mb-4 text-sm leading-normal text-gray-300">
        <time datetime="2023-04-11">2023-04-11</time><p class="my-0">
            Tags:
            <a href="https://salif.github.io/zola-themes-collection/demo/mo8it/tags/rust">#rust</a><span class="pr-1.5">,</span><a href="https://salif.github.io/zola-themes-collection/demo/mo8it/tags/database">#database</a></p>

        <p class="my-0">Reading time: ~13min</p>

        <hr class="my-2.5">
    </div>

        </div>

        <p><a href="https://github.com/launchbadge/sqlx">SQLx</a> is an async Rust crate that let's us interact with a database with compile-time checked queries 🧰</p>
<p>This post will be a short introduction to SQLx with PostgreSQL, but SQLx also supports MySQL, SQLite, and MSSQL.</p>
<p>The example will be a todo list in a database. <em>A classical programming example</em>, I know 😅</p>
<p>We will also see if SQLx protects us against SQL injections 💉</p>
<span id="continue-reading"></span>
    <p class="p-1 my-4 text-base rounded sm:hidden bg-yellow-200/20">Landscape mode recommended on mobile devices</p>

    
        <div class="px-4 pt-3 pb-0.5 mt-3 mb-1 bg-gray-800 rounded">
            <p class="text-2xl font-bold">Contents</p>

            <nav>
                <ul class="ml-0 list-none">
                    
                        
                    
                        
                            <li><a href="https://salif.github.io/zola-themes-collection/demo/mo8it/blog/sqlx-interacting-with-databases-in-rust/#database-preparation">Database preparation</a>
                                    <ul class="my-0 ml-5 list-none">
                                        
                                            
                                                <li><a class="text-base" href="https://salif.github.io/zola-themes-collection/demo/mo8it/blog/sqlx-interacting-with-databases-in-rust/#database-url">Database URL</a></li>
                                            
                                        
                                            
                                                <li><a class="text-base" href="https://salif.github.io/zola-themes-collection/demo/mo8it/blog/sqlx-interacting-with-databases-in-rust/#sqlx-cli">SQLx CLI</a></li>
                                            
                                        
                                            
                                                <li><a class="text-base" href="https://salif.github.io/zola-themes-collection/demo/mo8it/blog/sqlx-interacting-with-databases-in-rust/#migrations">Migrations</a></li>
                                            
                                        
                                    </ul>
                                </li>
                        
                    
                        
                            <li><a href="https://salif.github.io/zola-themes-collection/demo/mo8it/blog/sqlx-interacting-with-databases-in-rust/#dependencies">Dependencies</a>
                                    <ul class="my-0 ml-5 list-none">
                                        
                                            
                                                <li><a class="text-base" href="https://salif.github.io/zola-themes-collection/demo/mo8it/blog/sqlx-interacting-with-databases-in-rust/#imports">Imports</a></li>
                                            
                                        
                                    </ul>
                                </li>
                        
                    
                        
                            <li><a href="https://salif.github.io/zola-themes-collection/demo/mo8it/blog/sqlx-interacting-with-databases-in-rust/#connection-pool">Connection pool</a></li>
                        
                    
                        
                            <li><a href="https://salif.github.io/zola-themes-collection/demo/mo8it/blog/sqlx-interacting-with-databases-in-rust/#unchecked-queries">Unchecked queries</a></li>
                        
                    
                        
                            <li><a href="https://salif.github.io/zola-themes-collection/demo/mo8it/blog/sqlx-interacting-with-databases-in-rust/#compile-time-checked-queries">Compile-time checked queries</a></li>
                        
                    
                        
                            <li><a href="https://salif.github.io/zola-themes-collection/demo/mo8it/blog/sqlx-interacting-with-databases-in-rust/#adding-dropping-a-column">Adding/dropping a column</a></li>
                        
                    
                        
                            <li><a href="https://salif.github.io/zola-themes-collection/demo/mo8it/blog/sqlx-interacting-with-databases-in-rust/#fetching-multiple-rows">Fetching multiple rows</a></li>
                        
                    
                        
                            <li><a href="https://salif.github.io/zola-themes-collection/demo/mo8it/blog/sqlx-interacting-with-databases-in-rust/#sql-injections">SQL injections</a></li>
                        
                    
                        
                            <li><a href="https://salif.github.io/zola-themes-collection/demo/mo8it/blog/sqlx-interacting-with-databases-in-rust/#embedded-migrations">Embedded migrations</a></li>
                        
                    
                        
                            <li><a href="https://salif.github.io/zola-themes-collection/demo/mo8it/blog/sqlx-interacting-with-databases-in-rust/#compile-time-optimization">Compile-time optimization</a></li>
                        
                    
                        
                            <li><a href="https://salif.github.io/zola-themes-collection/demo/mo8it/blog/sqlx-interacting-with-databases-in-rust/#conclusion">Conclusion</a>
                                    <ul class="my-0 ml-5 list-none">
                                        
                                            
                                        
                                            
                                        
                                    </ul>
                                </li>
                        
                    
                </ul>
            </nav>
        </div>
    

<h4 id="disclaimer"><a class="text-white no-underline transition-none hover:underline"
   href="#disclaimer">Disclaimer</a></h4>
<p>This post is not about SQL. Therefore, the details of SQL statements will not be explained.</p>
<p>The post uses <code>unwrap</code> and <code>expect</code> to focus on the main concepts.
In a real project, you should do <strong>proper error handling!</strong></p>
<p>I will assume that you are familiar with the first few chapters of <a href="https://doc.rust-lang.org/stable/book">the Rust book</a> and know the basics of async Rust with <code>tokio</code>.</p>
<h2 id="database-preparation"><a class="text-white no-underline transition-none hover:underline"
   href="#database-preparation">Database preparation</a></h2>
<p>Before starting with SQLx, run PostgreSQL in the background to be able to connect to it.</p>
<p>The post <a href="https://salif.github.io/zola-themes-collection/demo/mo8it/blog/containerized-postgresql-with-rootless-podman/">"Containerized PostgreSQL with rootless Podman"</a> can help with setting up PostgreSQL.
But you don't have to use a container!</p>
<h3 id="database-url"><a class="text-white no-underline transition-none hover:underline"
   href="#database-url">Database URL</a></h3>
<p>Now that our database is running in the background, we want to provide information to SQLx to be able to connect to the database.</p>
<p>This information is the <code>DATABASE_URL</code> environment variable with the following general form for PostgreSQL:</p>
<pre style="background-color:#212733;color:#ccc9c2;"><code><span>postgresql://[user[:password]@][host][:port][/dbname][?param1=value1&amp;...]
</span></code></pre>
<p>You can check possible parameters (<code>param</code>) in this <a href="https://docs.rs/sqlx/latest/sqlx/postgres/struct.PgConnectOptions.html">documentation page</a>.</p>
<p>The easiest way to provide this environment variable during development is to store it in a <code>.env</code> file in the project's root directory (where <code>Cargo.toml</code> is):</p>
<pre style="background-color:#212733;color:#ccc9c2;"><code><span>DATABASE_URL=postgresql://postgres:CHANGE_ME@127.0.0.1:5432/postgres
</span></code></pre>
<p>I am using the connection details from the <a href="https://salif.github.io/zola-themes-collection/demo/mo8it/blog/containerized-postgresql-with-rootless-podman/">previous post</a>.
We are connecting to the database <code>postgres</code> at the host <code>127.0.0.1</code> (localhost) on port <code>5432</code> with the username <code>postgres</code> and the password <code>CHANGE_ME</code>.</p>
<p>Make sure you enter <strong>your</strong> connection details.</p>
<p>SQLx automatically extracts the environment variable from this file for the CLI (see below) and the compile-time query checks.</p>
<h3 id="sqlx-cli"><a class="text-white no-underline transition-none hover:underline"
   href="#sqlx-cli">SQLx CLI</a></h3>
<p>SQLx provides a CLI that helps during development. You can install it with <code>cargo</code>:</p>
<pre data-lang="fish" style="background-color:#212733;color:#ccc9c2;" class="language-fish "><code class="language-fish" data-lang="fish"><span style="color:#ffd580;">cargo </span><span>install sqlx-cli </span><span style="color:#ffcc66;">--no-default-features --features </span><span>rustls,postgres
</span></code></pre>
<div class="rounded-xl bg-sky-400/20">
    <div class="px-2 pt-2 pb-1 my-3 text-white">
        <p class="font-bold">Note</p>
        <p>You need to use different features if you are not using PostgreSQL.
See the <a href="https://github.com/launchbadge/sqlx/blob/main/sqlx-cli/README.md#install">installation docs</a>.</p>

    </div>
</div>
<p>Make sure that <code>~/.cargo/bin</code> is in your <code>PATH</code> to be able to call the binary <code>sqlx</code>.</p>
<p>The CLI has three subcommands which can be seen by running <code>sqlx --help</code>:</p>
<ul>
<li>The <code>database</code> subcommand allows you to <code>create</code>, <code>drop</code> and <code>reset</code> the database in <code>DATABASE_URL</code>.</li>
<li>The <code>prepare</code> subcommand allows support for compile-time query checks in <em>offline mode</em> which is useful if you don't want to keep the database running in the background.</li>
<li>The <code>migrate</code> subcommand allows you to <code>add</code> and <code>run</code> database migrations which we will use in the next section.</li>
</ul>
<h3 id="migrations"><a class="text-white no-underline transition-none hover:underline"
   href="#migrations">Migrations</a></h3>
<p>Since our database is still empty, we want to create a table to interact with in our code.</p>
<p>We could create our tables manually by connecting to the database with <code>psql</code> and running some SQL statements.
But to automate the migrations process, we should use SQLx migrations.</p>
<p>First, make sure that the database exists with the following command:</p>
<pre data-lang="fish" style="background-color:#212733;color:#ccc9c2;" class="language-fish "><code class="language-fish" data-lang="fish"><span style="color:#ffd580;">sqlx </span><span>database create
</span></code></pre>
<p>Now, let's create our first migration with the following command:</p>
<pre data-lang="fish" style="background-color:#212733;color:#ccc9c2;" class="language-fish "><code class="language-fish" data-lang="fish"><span style="color:#ffd580;">sqlx </span><span>migrate add create_todos_table
</span></code></pre>
<p><code>create_todos_table</code> is the migration description. The output of this command is very helpful:</p>
<pre style="background-color:#212733;color:#ccc9c2;"><code><span>Creating migrations/20230409131413_create_todos_table.sql
</span><span>
</span><span>Congratulations on creating your first migration!
</span><span>
</span><span>Did you know you can embed your migrations in your application binary?
</span><span>On startup, after creating your database connection or pool, add:
</span><span>
</span><span>sqlx::migrate!().run(&lt;&amp;your_pool OR &amp;mut your_connection&gt;).await?;
</span><span>
</span><span>Note that the compiler won&#39;t pick up new migrations if no Rust source files have changed.
</span><span>You can create a Cargo build script to work around this with `sqlx migrate build-script`.
</span><span>
</span><span>See: https://docs.rs/sqlx/0.6.3/sqlx/macro.migrate.html
</span></code></pre>
<p>The command did create the directory <code>migrations</code> in the project's root directory with the file <code>&lt;timestamp&gt;_&lt;description&gt;.sql</code>.</p>
<p>It does also tell us about embedding and running the migrations in our code which we will do later.</p>
<p>To trigger recompilation for the compile-time query checks after a new migration, we will follow the tip in the command output above and run the following command:</p>
<pre data-lang="fish" style="background-color:#212733;color:#ccc9c2;" class="language-fish "><code class="language-fish" data-lang="fish"><span style="color:#ffd580;">sqlx </span><span>migrate build-script
</span></code></pre>
<p>This will create a <code>build.rs</code> file that triggers recompilation after changes in the <code>migrations</code> directory.</p>
<p>Now, let's write our first migration in the file created with <code>sqlx migrate add</code>:</p>
<pre data-lang="sql" style="background-color:#212733;color:#ccc9c2;" class="language-sql "><code class="language-sql" data-lang="sql"><span style="color:#ffa759;">CREATE TABLE </span><span>IF NOT EXISTS </span><span style="color:#ffd580;">todos</span><span> (
</span><span>    id </span><span style="color:#ffa759;">SERIAL PRIMARY KEY</span><span>,
</span><span>    title </span><span style="color:#ffa759;">TEXT </span><span style="color:#f29e74;">NOT </span><span style="color:#ffcc66;">NULL</span><span>,
</span><span>    done </span><span style="color:#ffa759;">BOOLEAN </span><span style="color:#f29e74;">NOT </span><span style="color:#ffcc66;">NULL </span><span style="color:#ffa759;">DEFAULT </span><span>false
</span><span>);
</span></code></pre>
<p>This SQL statement creates a table called <code>todos</code> with a self incrementing <code>id</code> as the primary key, a text <code>title</code> and a boolean <code>done</code> that defaults to <code>false</code>.</p>
<p>To run this migration, run the following command:</p>
<pre data-lang="fish" style="background-color:#212733;color:#ccc9c2;" class="language-fish "><code class="language-fish" data-lang="fish"><span style="color:#ffd580;">sqlx </span><span>migrate run
</span></code></pre>
<p>You have applied your first migration 🎉</p>
<div class="rounded-xl bg-sky-400/20">
    <div class="px-2 pt-2 pb-1 my-3 text-white">
        <p class="font-bold">Note</p>
        <p>SQLx supports reversible migrations which can be created with <code>sqlx migrate add -r</code>.
This creates the two files <code>&lt;timestamp&gt;_&lt;description&gt;.up.sql</code> and <code>&lt;timestamp&gt;_&lt;description&gt;.down.sql</code>.</p>
<p>You can then revert a migration with <code>sqlx migrate revert</code>.</p>

    </div>
</div>
<p>You can create and run future migrations the same way.
SQLx will then only run migrations that are not applied yet.
Applied migrations are tracked in a special table in the database called <code>_sqlx_migrations</code>.</p>
<p>Now that our database is prepared, we can finally start interacting with it through code 🦀</p>
<h2 id="dependencies"><a class="text-white no-underline transition-none hover:underline"
   href="#dependencies">Dependencies</a></h2>
<p>The example uses the following crates:</p>
<ul>
<li><a href="https://docs.rs/sqlx/0.6.3/sqlx">sqlx</a>: Async SQL toolkit</li>
<li><a href="https://docs.rs/tokio/1.27.0/tokio">tokio</a>: Asynchronous runtime</li>
<li><a href="https://docs.rs/futures/0.3.28/futures">futures</a>: Needed to handle async streams</li>
<li><a href="https://docs.rs/dotenvy/0.15.7/dotenvy">dotenvy</a>: Loads environment variables from the <code>.env</code> file</li>
</ul>
<p>To follow the example, add the following dependencies to <code>Cargo.toml</code>:</p>
<pre data-lang="toml" style="background-color:#212733;color:#ccc9c2;" class="language-toml "><code class="language-toml" data-lang="toml"><span>[</span><span style="color:#73d0ff;">dependencies</span><span>]
</span><span style="color:#73d0ff;">dotenvy </span><span>= </span><span style="color:#bae67e;">&quot;0.15.7&quot;
</span><span style="color:#73d0ff;">futures </span><span>= </span><span style="color:#bae67e;">&quot;0.3.28&quot;
</span><span style="color:#73d0ff;">sqlx </span><span>= { </span><span style="color:#73d0ff;">version </span><span>= </span><span style="color:#bae67e;">&quot;0.6.3&quot;</span><span style="color:#ccc9c2cc;">, </span><span style="color:#73d0ff;">features </span><span>= [</span><span style="color:#bae67e;">&quot;postgres&quot;</span><span style="color:#ccc9c2cc;">, </span><span style="color:#bae67e;">&quot;macros&quot;</span><span style="color:#ccc9c2cc;">, </span><span style="color:#bae67e;">&quot;runtime-tokio-rustls&quot;</span><span>] }
</span><span style="color:#73d0ff;">tokio </span><span>= { </span><span style="color:#73d0ff;">version </span><span>= </span><span style="color:#bae67e;">&quot;1.27.0&quot;</span><span style="color:#ccc9c2cc;">, </span><span style="color:#73d0ff;">features </span><span>= [</span><span style="color:#bae67e;">&quot;macros&quot;</span><span style="color:#ccc9c2cc;">, </span><span style="color:#bae67e;">&quot;rt-multi-thread&quot;</span><span>] }
</span></code></pre>
<h3 id="imports"><a class="text-white no-underline transition-none hover:underline"
   href="#imports">Imports</a></h3>
<p>All imports used in the example are gathered below to keep later code snippets slim:</p>
<pre data-lang="rust" style="background-color:#212733;color:#ccc9c2;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#ffa759;">use </span><span>futures</span><span style="color:#f29e74;">::</span><span>TryStreamExt</span><span style="color:#ccc9c2cc;">;
</span><span style="color:#ffa759;">use </span><span>sqlx</span><span style="color:#f29e74;">::</span><span>postgres</span><span style="color:#f29e74;">::</span><span>PgPoolOptions</span><span style="color:#ccc9c2cc;">;
</span><span style="color:#ffa759;">use </span><span>std</span><span style="color:#f29e74;">::</span><span>env</span><span style="color:#ccc9c2cc;">;
</span></code></pre>
<h2 id="connection-pool"><a class="text-white no-underline transition-none hover:underline"
   href="#connection-pool">Connection pool</a></h2>
<p>Since SQLx is async, we need <code>tokio</code> to make the <code>main</code> function async.</p>
<p>We will use <code>dotenvy</code> to add the content of the <code>.env</code> file.
Then, we will use the environment variable <code>DATABASE_URL</code> to create a connection pool to the database:</p>
<pre data-lang="rust" style="background-color:#212733;color:#ccc9c2;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#ccc9c2cc;">#</span><span>[</span><span style="color:#ffd580;">tokio</span><span>::</span><span style="color:#ffd580;">main</span><span>]
</span><span>async </span><span style="color:#ffa759;">fn </span><span style="color:#ffd580;">main</span><span>() {
</span><span>    dotenvy</span><span style="color:#f29e74;">::</span><span>dotenv()</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">expect</span><span>(</span><span style="color:#bae67e;">&quot;Could not load the .env file!&quot;</span><span>)</span><span style="color:#ccc9c2cc;">;
</span><span>    </span><span style="color:#ffa759;">let</span><span> database_url </span><span style="color:#f29e74;">=
</span><span>        env</span><span style="color:#f29e74;">::</span><span>var(</span><span style="color:#bae67e;">&quot;DATABASE_URL&quot;</span><span>)</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">expect</span><span>(</span><span style="color:#bae67e;">&quot;The environment variable DATABASE_URL is missing!&quot;</span><span>)</span><span style="color:#ccc9c2cc;">;
</span><span>
</span><span>    </span><span style="color:#ffa759;">let</span><span> pool </span><span style="color:#f29e74;">= </span><span>PgPoolOptions</span><span style="color:#f29e74;">::</span><span>new()
</span><span>        </span><span style="color:#f29e74;">.</span><span style="color:#f28779;">connect</span><span>(</span><span style="color:#f29e74;">&amp;</span><span>database_url)
</span><span>        </span><span style="color:#f29e74;">.</span><span>await
</span><span>        </span><span style="color:#f29e74;">.</span><span style="color:#f28779;">expect</span><span>(</span><span style="color:#bae67e;">&quot;Failed to connect to the database!&quot;</span><span>)</span><span style="color:#ccc9c2cc;">;
</span><span>}
</span></code></pre>
<p>A connection pool manages opening and re-using multiple database connections. The maximum number of connections can be provided with <a href="https://docs.rs/sqlx/0.6.3/sqlx/pool/struct.PoolOptions.html#method.max_connections"><code>max_connections</code></a> before <code>connect</code>.</p>
<p>Although SQLx provides a way to open a single database connection,
a connection pool should always be used instead of expensively opening a connection for every operation.</p>
<p>Now that we have a connection pool, we can try some queries!</p>
<h2 id="unchecked-queries"><a class="text-white no-underline transition-none hover:underline"
   href="#unchecked-queries">Unchecked queries</a></h2>
<p>First, we will see how to run a query that is <em>not</em> checked at compile-time:</p>
<pre data-lang="rust" style="background-color:#212733;color:#ccc9c2;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#ffa759;">let</span><span> first_todo_title </span><span style="color:#f29e74;">= </span><span style="color:#bae67e;">&quot;Learn SQLx&quot;</span><span style="color:#ccc9c2cc;">;
</span><span>
</span><span>sqlx</span><span style="color:#f29e74;">::</span><span>query(</span><span style="color:#bae67e;">&quot;INSERT INTO todos (title) VALUES ($1)&quot;</span><span>)
</span><span>    </span><span style="color:#f29e74;">.</span><span style="color:#f28779;">bind</span><span>(first_todo_title)
</span><span>    </span><span style="color:#f29e74;">.</span><span style="color:#f28779;">execute</span><span>(</span><span style="color:#f29e74;">&amp;</span><span>pool)
</span><span>    </span><span style="color:#f29e74;">.</span><span>await
</span><span>    </span><span style="color:#f29e74;">.</span><span style="color:#f28779;">unwrap</span><span>()</span><span style="color:#ccc9c2cc;">;
</span></code></pre>
<p>"Wait a minute", you might think, "this is just SQL! It is not what I did expect from a database library 🤨"</p>
<p>If you had this though, then you were expecting an <a href="https://en.wikipedia.org/wiki/Object%E2%80%93relational_mapping">ORM</a>.
SQLx is <em>not</em> an ORM.
This means that you will just use normal SQL statements to interact with the database.
We will discuss how the SQLx approach compares to an ORM at the end of the post.</p>
<p>Now, let's discuss the snippet above.
The function <code>query</code> takes a SQL query as input with <code>$1</code> .. <code>$N</code> as parameters.</p>
<p>The values of the parameters are provided by calling <code>bind</code> <code>N</code> times with respect to the order of the parameters.
Since we only have one parameter (<code>$1</code>), we call <code>bind</code> once with the value as the title of our first todo.</p>
<p>Congratulations, you made your first query with SQLx 🎉</p>
<p>Now, how can we retrieve something from the database?</p>
<p>We can use <code>query_as</code> to run a query and interpret the database output as an instance of a struct.
Let's create a struct that represents a row in the <code>todos</code> table:</p>
<pre data-lang="rust" style="background-color:#212733;color:#ccc9c2;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#ccc9c2cc;">#</span><span>[</span><span style="color:#ffd580;">derive</span><span>(sqlx::FromRow)]
</span><span style="color:#ffa759;">struct </span><span style="color:#73d0ff;">Todo </span><span>{
</span><span>    id</span><span style="color:#ccc9c2cc;">: </span><span style="color:#ffa759;">i32</span><span>,
</span><span>    title</span><span style="color:#ccc9c2cc;">:</span><span> String,
</span><span>    done</span><span style="color:#ccc9c2cc;">: </span><span style="color:#ffa759;">bool</span><span>,
</span><span>}
</span></code></pre>
<p>Notice the need to derive <code>sqlx::FromRow</code> for using the struct with <code>query_as</code>.</p>
<p>Now, we can run the following to get the inserted first todo from the database:</p>
<pre data-lang="rust" style="background-color:#212733;color:#ccc9c2;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#ffa759;">let</span><span> first_todo </span><span style="color:#f29e74;">= </span><span>sqlx</span><span style="color:#f29e74;">::</span><span>query_as</span><span style="color:#f29e74;">::</span><span>&lt;</span><span style="color:#f29e74;">_</span><span>, Todo&gt;(</span><span style="color:#bae67e;">&quot;SELECT * FROM todos WHERE title=$1&quot;</span><span>)
</span><span>    </span><span style="color:#f29e74;">.</span><span style="color:#f28779;">bind</span><span>(first_todo_title)
</span><span>    </span><span style="color:#f29e74;">.</span><span style="color:#f28779;">fetch_one</span><span>(</span><span style="color:#f29e74;">&amp;</span><span>pool)
</span><span>    </span><span style="color:#f29e74;">.</span><span>await
</span><span>    </span><span style="color:#f29e74;">.</span><span style="color:#f28779;">unwrap</span><span>()</span><span style="color:#ccc9c2cc;">;
</span></code></pre>
<p>We use <code>fetch_one</code> because we are expecting a single row as a result.
If you want to retrieve multiple rows, you can use <code>fetch</code> or <code>fetch_all</code> that we will cover in a later section.</p>
<p>We can use <code>first_todo</code> just as any instance of <code>Todo</code>:</p>
<pre data-lang="rust" style="background-color:#212733;color:#ccc9c2;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#f28779;">println!</span><span>(
</span><span>    </span><span style="color:#bae67e;">&quot;query_as: id=</span><span style="color:#ffcc66;">{}</span><span style="color:#bae67e;">, title=</span><span style="color:#ffcc66;">{}</span><span style="color:#bae67e;">, done=</span><span style="color:#ffcc66;">{:?}</span><span style="color:#bae67e;">&quot;</span><span style="color:#ccc9c2cc;">,
</span><span>    first_todo</span><span style="color:#f29e74;">.</span><span>id</span><span style="color:#ccc9c2cc;">,</span><span> first_todo</span><span style="color:#f29e74;">.</span><span>title</span><span style="color:#ccc9c2cc;">,</span><span> first_todo</span><span style="color:#f29e74;">.</span><span>done
</span><span>)</span><span style="color:#ccc9c2cc;">;
</span></code></pre>
<p>The output should be the following:</p>
<pre style="background-color:#212733;color:#ccc9c2;"><code><span>query_as: id=1, title=Learn SQLx, done=false
</span></code></pre>
<p>You can run any other SQL statement using <code>query</code> and <code>query_as</code>.
Your only limits are the features that the database system supports!
As a demonstration, we will add the following statement before the first <code>INSERT</code> statement to start with a clean table and avoid confusion when running the program multiple times:</p>
<pre data-lang="rust" style="background-color:#212733;color:#ccc9c2;" class="language-rust "><code class="language-rust" data-lang="rust"><span>sqlx</span><span style="color:#f29e74;">::</span><span>query(</span><span style="color:#bae67e;">&quot;TRUNCATE TABLE todos RESTART IDENTITY&quot;</span><span>)
</span><span>    </span><span style="color:#f29e74;">.</span><span style="color:#f28779;">execute</span><span>(</span><span style="color:#f29e74;">&amp;</span><span>pool)
</span><span>    </span><span style="color:#f29e74;">.</span><span>await
</span><span>    </span><span style="color:#f29e74;">.</span><span style="color:#f28779;">expect</span><span>(</span><span style="color:#bae67e;">&quot;Failed to truncate table!&quot;</span><span>)</span><span style="color:#ccc9c2cc;">;
</span></code></pre>
<div class="rounded-xl bg-yellow-400/20">
    <div class="px-2 pt-2 pb-1 my-3 text-white">
        <p class="font-bold">⚠️ Warning ⚠️</p>
        <p>The <a href="https://www.postgresql.org/docs/15/sql-truncate.html"><code>TRUNCATE</code> statement</a> above <strong>deletes all data</strong> in the table!</p>
<p>It is used here to start with a clean table and avoid confusion resulted by running the program multiple times which itself results in multiple <code>INSERT</code> statements.</p>

    </div>
</div>
<h2 id="compile-time-checked-queries"><a class="text-white no-underline transition-none hover:underline"
   href="#compile-time-checked-queries">Compile-time checked queries</a></h2>
<p>Now, let's try queries that are checked at compile-time.
Such queries require the development database to be reachable during compilation.
An alternative would be the <em>offline mode</em> that can be prepared with the SQLx CLI.</p>
<p>An example for such a query is the following:</p>
<pre data-lang="rust" style="background-color:#212733;color:#ccc9c2;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#ffa759;">let</span><span> second_todo_title </span><span style="color:#f29e74;">= </span><span style="color:#bae67e;">&quot;Give feedback to this blog post&quot;</span><span style="color:#ccc9c2cc;">;
</span><span>
</span><span>sqlx</span><span style="color:#f29e74;">::</span><span>query</span><span style="color:#f29e74;">!</span><span>(</span><span style="color:#bae67e;">&quot;INSERT INTO todos (title) VALUES ($1)&quot;</span><span style="color:#ccc9c2cc;">,</span><span> second_todo_title)
</span><span>    </span><span style="color:#f29e74;">.</span><span style="color:#f28779;">execute</span><span>(</span><span style="color:#f29e74;">&amp;</span><span>pool)
</span><span>    </span><span style="color:#f29e74;">.</span><span>await
</span><span>    </span><span style="color:#f29e74;">.</span><span style="color:#f28779;">unwrap</span><span>()</span><span style="color:#ccc9c2cc;">;
</span></code></pre>
<p>The syntax difference to <code>query</code> is that the macro <code>query!</code> takes the values of the parameters as arguments after the query.</p>
<p>The advantage of the macro is that SQLx connects to the development database and lets the database itself verify the query with the value types provided.</p>
<p>If, for example, the table <code>todos</code> doesn't exist, the program will not compile!
You will get a compilation error with the error message from the database.
In this case, you might have forgotten to run the migrations.</p>
<p>The macro checks the type of the values provided.
If we replace the provided value <code>second_todo_title</code> with some number like <code>42</code>, SQLx will tell us that it was expecting <code>&amp;str</code> because the title has the type <code>TEXT</code> in the database!</p>
<p>We will see the real advantage of the compile-time checks in the next section.
But first, let's see the equivalence of the function <code>query_as</code> as a macro:</p>
<pre data-lang="rust" style="background-color:#212733;color:#ccc9c2;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#ffa759;">let</span><span> second_todo </span><span style="color:#f29e74;">= </span><span>sqlx</span><span style="color:#f29e74;">::</span><span>query_as</span><span style="color:#f29e74;">!</span><span>(
</span><span>    Todo</span><span style="color:#ccc9c2cc;">,
</span><span>    </span><span style="color:#bae67e;">&quot;SELECT * FROM todos WHERE title=$1&quot;</span><span style="color:#ccc9c2cc;">,
</span><span>    second_todo_title
</span><span>)
</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">fetch_one</span><span>(</span><span style="color:#f29e74;">&amp;</span><span>pool)
</span><span style="color:#f29e74;">.</span><span>await
</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">unwrap</span><span>()</span><span style="color:#ccc9c2cc;">;
</span></code></pre>
<p>The syntax differences are the following:</p>
<ul>
<li>The struct is provided as the first argument.</li>
<li>The parameter values are provided as arguments after the query instead of using <code>bind</code>.</li>
</ul>
<div class="rounded-xl bg-sky-400/20">
    <div class="px-2 pt-2 pb-1 my-3 text-white">
        <p class="font-bold">Note</p>
        <p>A struct doesn't have to derive <code>sqlx::FromRow</code> for using the macro <code>query_as!</code>.</p>

    </div>
</div>
<h2 id="adding-dropping-a-column"><a class="text-white no-underline transition-none hover:underline"
   href="#adding-dropping-a-column">Adding/dropping a column</a></h2>
<p>Now, let's add a column to practice migrations and experience the major advantage of the compile-time checked queries.
We will add a column for an optional <code>description</code>.</p>
<p>First, we will create a new migration:</p>
<pre data-lang="fish" style="background-color:#212733;color:#ccc9c2;" class="language-fish "><code class="language-fish" data-lang="fish"><span style="color:#ffd580;">sqlx </span><span>migrate add add_description_column
</span></code></pre>
<p>Now, enter the following in the new migration file:</p>
<pre data-lang="sql" style="background-color:#212733;color:#ccc9c2;" class="language-sql "><code class="language-sql" data-lang="sql"><span style="color:#ffa759;">ALTER TABLE </span><span>todos
</span><span>ADD COLUMN IF NOT </span><span style="color:#f29e74;">EXISTS</span><span> description </span><span style="color:#ffa759;">TEXT</span><span>;
</span></code></pre>
<p>Let's apply this migration with the following command:</p>
<pre data-lang="fish" style="background-color:#212733;color:#ccc9c2;" class="language-fish "><code class="language-fish" data-lang="fish"><span style="color:#ffd580;">sqlx </span><span>migrate run
</span></code></pre>
<p>The changes are applied to the database 🎉</p>
<p>But what about our code? Let's try to compile it as is! We will become the following error that points to the <code>SELECT</code> statement with the macro <code>query_as!</code>:</p>
<pre style="background-color:#212733;color:#ccc9c2;"><code><span>struct `Todo` has no field named `description`
</span></code></pre>
<p>This feels like magic 🪄</p>
<p>Remember, we did not change our code, we did not even run our program to find the bug at runtime. No, this error is <em>shifted to compile-time!</em></p>
<p>Let's fix the error by adding the following field to our <code>Todo</code> struct:</p>
<pre data-lang="rust" style="background-color:#212733;color:#ccc9c2;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#ffa759;">struct </span><span style="color:#73d0ff;">Todo </span><span>{
</span><span>    </span><span style="font-style:italic;color:#5c6773;">// ...
</span><span>    description</span><span style="color:#ccc9c2cc;">: </span><span style="font-style:italic;color:#5ccfe6;">Option</span><span>&lt;</span><span style="font-style:italic;color:#5ccfe6;">String</span><span>&gt;,
</span><span>}
</span></code></pre>
<p>We use <code>Option</code> because the description is nullable in the database.</p>
<p>Now, our code compiles again 🎉</p>
<p>Let's add two more todos with a description, one with the function <code>query</code> and one with the macro <code>query!</code>:</p>
<pre data-lang="rust" style="background-color:#212733;color:#ccc9c2;" class="language-rust "><code class="language-rust" data-lang="rust"><span>sqlx</span><span style="color:#f29e74;">::</span><span>query(</span><span style="color:#bae67e;">&quot;INSERT INTO todos (title, description) VALUES ($1, $2)&quot;</span><span>)
</span><span>    </span><span style="color:#f29e74;">.</span><span style="color:#f28779;">bind</span><span>(</span><span style="color:#bae67e;">&quot;Learn SQL&quot;</span><span>)
</span><span>    </span><span style="color:#f29e74;">.</span><span style="color:#f28779;">bind</span><span>(</span><span style="color:#bae67e;">&quot;To understand the statements in this blog post&quot;</span><span>)
</span><span>    </span><span style="color:#f29e74;">.</span><span style="color:#f28779;">execute</span><span>(</span><span style="color:#f29e74;">&amp;</span><span>pool)
</span><span>    </span><span style="color:#f29e74;">.</span><span>await
</span><span>    </span><span style="color:#f29e74;">.</span><span style="color:#f28779;">unwrap</span><span>()</span><span style="color:#ccc9c2cc;">;
</span><span>
</span><span>sqlx</span><span style="color:#f29e74;">::</span><span>query</span><span style="color:#f29e74;">!</span><span>(
</span><span>    </span><span style="color:#bae67e;">&quot;INSERT INTO todos (title, description) VALUES ($1, $2)&quot;</span><span style="color:#ccc9c2cc;">,
</span><span>    </span><span style="color:#bae67e;">&quot;Learn Axum&quot;</span><span style="color:#ccc9c2cc;">,
</span><span>    </span><span style="color:#bae67e;">&quot;To write a Rust backend&quot;
</span><span>)
</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">execute</span><span>(</span><span style="color:#f29e74;">&amp;</span><span>pool)
</span><span style="color:#f29e74;">.</span><span>await
</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">unwrap</span><span>()</span><span style="color:#ccc9c2cc;">;
</span></code></pre>
<p>Both work! But let's say that at a later point in the future we don't like descriptions anymore. We want to drop the column 🗑️</p>
<p>Apply the following migration:</p>
<pre data-lang="sql" style="background-color:#212733;color:#ccc9c2;" class="language-sql "><code class="language-sql" data-lang="sql"><span style="color:#ffa759;">ALTER TABLE </span><span>todos
</span><span>DROP COLUMN IF </span><span style="color:#f29e74;">EXISTS</span><span> description;
</span></code></pre>
<p>Now, compile again.
You will get two errors.
This first one is solved by removing the field <code>description</code> from the <code>Todo</code> struct.
The second error is the following:</p>
<pre style="background-color:#212733;color:#ccc9c2;"><code><span>error returned from database: column &quot;description&quot; of relation &quot;todos&quot; does not exist
</span></code></pre>
<p>This error is from the macro <code>query!</code> with the todo "Learn Axum".
The query references <code>description</code>, but the column doesn't exist anymore and the database complains.</p>
<p>Why am I stressing this point?
I am sure you did get that the checks at compile-time are very useful.</p>
<p>What I want to show is the alternative to compile-time checks.
To see it, let's fix the compiler error by removing the description from the macro <code>query!</code> and run the program:</p>
<pre data-lang="rust" style="background-color:#212733;color:#ccc9c2;" class="language-rust "><code class="language-rust" data-lang="rust"><span>sqlx</span><span style="color:#f29e74;">::</span><span>query</span><span style="color:#f29e74;">!</span><span>(</span><span style="color:#bae67e;">&quot;INSERT INTO todos (title) VALUES ($1)&quot;</span><span style="color:#ccc9c2cc;">, </span><span style="color:#bae67e;">&quot;Learn Axum&quot;</span><span>)
</span><span>    </span><span style="color:#f29e74;">.</span><span style="color:#f28779;">execute</span><span>(</span><span style="color:#f29e74;">&amp;</span><span>pool)
</span><span>    </span><span style="color:#f29e74;">.</span><span>await
</span><span>    </span><span style="color:#f29e74;">.</span><span style="color:#f28779;">unwrap</span><span>()</span><span style="color:#ccc9c2cc;">;
</span></code></pre>
<p>Our program runs, but then... PAM 💥
A runtime error that leads to a panic because of the function <code>query</code> with a description.
We forgot to adopt the change from the migration here.</p>
<p>Of course, it is our fault that the program panics because we did use <code>unwrap</code> which you <strong>should not use in a real project</strong>.
But the point is that the error occurs anyway, but <strong>at runtime</strong>!
The users of your program will probably discover the error after your product is published, not you... ☠️</p>
<p>Or you have to write unit tests for every query and hope that such errors get caught... 🥲</p>
<h2 id="fetching-multiple-rows"><a class="text-white no-underline transition-none hover:underline"
   href="#fetching-multiple-rows">Fetching multiple rows</a></h2>
<p>We did see that we can use <code>fetch_one</code> to retrieve a single row.
To retrieve multiple rows, we can either use <code>fetch</code> or <code>fetch_all</code>.</p>
<p><code>fetch_all</code> returns a simple vector of rows. Here is how to use it:</p>
<pre data-lang="rust" style="background-color:#212733;color:#ccc9c2;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#ffa759;">let</span><span> todos </span><span style="color:#f29e74;">= </span><span>sqlx</span><span style="color:#f29e74;">::</span><span>query_as</span><span style="color:#f29e74;">!</span><span>(Todo</span><span style="color:#ccc9c2cc;">, </span><span style="color:#bae67e;">&quot;SELECT * FROM todos&quot;</span><span>)
</span><span>    </span><span style="color:#f29e74;">.</span><span style="color:#f28779;">fetch_all</span><span>(</span><span style="color:#f29e74;">&amp;</span><span>pool)
</span><span>    </span><span style="color:#f29e74;">.</span><span>await
</span><span>    </span><span style="color:#f29e74;">.</span><span style="color:#f28779;">unwrap</span><span>()</span><span style="color:#ccc9c2cc;">;
</span><span>
</span><span style="color:#ffa759;">for</span><span> todo </span><span style="color:#f29e74;">in</span><span> todos {
</span><span>    </span><span style="color:#f28779;">println!</span><span>(</span><span style="color:#bae67e;">&quot;title=</span><span style="color:#ffcc66;">{}</span><span style="color:#bae67e;">, done=</span><span style="color:#ffcc66;">{:?}</span><span style="color:#bae67e;">&quot;</span><span style="color:#ccc9c2cc;">,</span><span> todo</span><span style="color:#f29e74;">.</span><span>title</span><span style="color:#ccc9c2cc;">,</span><span> todo</span><span style="color:#f29e74;">.</span><span>done)</span><span style="color:#ccc9c2cc;">;
</span><span>}
</span></code></pre>
<p>On the other hand, <code>fetch</code> returns an async stream from the database.
This means that the results are not collected into a vector first which prevents unneeded allocations:</p>
<pre data-lang="rust" style="background-color:#212733;color:#ccc9c2;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#ffa759;">let mut</span><span> todos_stream </span><span style="color:#f29e74;">= </span><span>sqlx</span><span style="color:#f29e74;">::</span><span>query_as</span><span style="color:#f29e74;">!</span><span>(Todo</span><span style="color:#ccc9c2cc;">, </span><span style="color:#bae67e;">&quot;SELECT * FROM todos&quot;</span><span>)</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">fetch</span><span>(</span><span style="color:#f29e74;">&amp;</span><span>pool)</span><span style="color:#ccc9c2cc;">;
</span><span>
</span><span style="color:#ffa759;">while let </span><span style="font-style:italic;color:#5ccfe6;">Some</span><span>(todo) </span><span style="color:#f29e74;">=</span><span> todos_stream</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">try_next</span><span>()</span><span style="color:#f29e74;">.</span><span>await</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">unwrap</span><span>() {
</span><span>    </span><span style="color:#f28779;">println!</span><span>(</span><span style="color:#bae67e;">&quot;title=</span><span style="color:#ffcc66;">{}</span><span style="color:#bae67e;">, done=</span><span style="color:#ffcc66;">{:?}</span><span style="color:#bae67e;">&quot;</span><span style="color:#ccc9c2cc;">,</span><span> todo</span><span style="color:#f29e74;">.</span><span>title</span><span style="color:#ccc9c2cc;">,</span><span> todo</span><span style="color:#f29e74;">.</span><span>done)</span><span style="color:#ccc9c2cc;">;
</span><span>}
</span></code></pre>
<p>Make sure to import the trait <code>futures::TryStreamExt</code> to be able to run <code>try_next</code> on the stream.</p>
<h2 id="sql-injections"><a class="text-white no-underline transition-none hover:underline"
   href="#sql-injections">SQL injections</a></h2>
<p>There is one big misconception I had about SQLx that prevented me from using it for some time because I thought it would be vulnerable to <a href="https://en.wikipedia.org/wiki/SQL_injection">SQL injections</a>.</p>
<p>I thought that <code>query</code> and <code>query!</code> work by replacing the parameters <code>$1</code> .. <code>$N</code> with the provided values like how <code>format!</code> works. This is not true!</p>
<p>SQLx sends the queries unmodified (with the parameters <code>$1</code> .. <code>$N</code>) to the database and the <em>parameter values</em> are sent <strong>in addition</strong>.
There is no formatting like with <code>format!</code>.
The database itself takes care of preventing SQL injections in these <a href="https://en.wikipedia.org/wiki/Prepared_statement">parameterized queries</a>.</p>
<p>An ORM is not safer than parameterized queries!</p>
<p>A parameterized query is not only safe, but also more efficient than a normal query because it can be prepared in isolation from the parameter values.</p>
<div class="rounded-xl bg-yellow-400/20">
    <div class="px-2 pt-2 pb-1 my-3 text-white">
        <p class="font-bold">⚠️ Warning ⚠️</p>
        <p>If you do use string formatting like <code>format!</code> for your queries, then you <strong>bypass the security</strong> of parameterized queries!</p>
<p>Use parameters <code>$1</code> .. <code>$N</code> instead of string formatting like with <code>format!</code> ⚠️</p>
<p>The macros <code>query!</code> and <code>query_as!</code> only accept string literals or a concatenation of string literals with <code>+</code> which prevents using string formatting in the first place.
But the functions <code>query</code> and <code>query_as</code> are not immune!</p>

    </div>
</div>
<h2 id="embedded-migrations"><a class="text-white no-underline transition-none hover:underline"
   href="#embedded-migrations">Embedded migrations</a></h2>
<p>During development, you need to use the SQLx CLI to run migrations.
But you can embed migration in the binary and run them automatically when deploying the binary.</p>
<p>To do so, add the following snippet just after creating the connection pool:</p>
<pre data-lang="rust" style="background-color:#212733;color:#ccc9c2;" class="language-rust "><code class="language-rust" data-lang="rust"><span>sqlx</span><span style="color:#f29e74;">::</span><span>migrate</span><span style="color:#f29e74;">!</span><span>()
</span><span>    </span><span style="color:#f29e74;">.</span><span style="color:#f28779;">run</span><span>(</span><span style="color:#f29e74;">&amp;</span><span>pool)
</span><span>    </span><span style="color:#f29e74;">.</span><span>await
</span><span>    </span><span style="color:#f29e74;">.</span><span style="color:#f28779;">expect</span><span>(</span><span style="color:#bae67e;">&quot;Failed to run migrations!&quot;</span><span>)</span><span style="color:#ccc9c2cc;">;
</span></code></pre>
<h2 id="compile-time-optimization"><a class="text-white no-underline transition-none hover:underline"
   href="#compile-time-optimization">Compile-time optimization</a></h2>
<p>Because of the checks that SQLx does at compile-time,
it is recommended to add the following to the end of your <code>Cargo.toml</code> file to optimize these checks and speed up compilation:</p>
<pre data-lang="toml" style="background-color:#212733;color:#ccc9c2;" class="language-toml "><code class="language-toml" data-lang="toml"><span>[</span><span style="color:#73d0ff;">profile</span><span style="color:#ccc9c2cc;">.</span><span style="color:#73d0ff;">dev</span><span style="color:#ccc9c2cc;">.</span><span style="color:#73d0ff;">package</span><span style="color:#ccc9c2cc;">.</span><span style="color:#73d0ff;">sqlx-macros</span><span>]
</span><span style="color:#73d0ff;">opt-level </span><span>= </span><span style="color:#ffcc66;">3
</span></code></pre>
<h2 id="conclusion"><a class="text-white no-underline transition-none hover:underline"
   href="#conclusion">Conclusion</a></h2>
<p>SQLx is a very flexible and powerful tool.
It allows you to use any feature your database provides by just using SQL statements.
But at the same time, its macros automagically validate your queries at compile-time 🪄</p>
<p>Personally, I don't see myself going back to ORMs after trying SQLx.
ORMs are just another layer of abstraction without many advantages in comparison to SQLx.
With ORMs, you need to learn the specific restricting API of every new ORM you use and forget your SQL skills that you need at some point anyway.</p>
<p>SQLx is simple, safe, flexible and powerful 🚀</p>
<p>Finally, we can check our todo "Learn SQLx" 😉</p>
<pre data-lang="rust" style="background-color:#212733;color:#ccc9c2;" class="language-rust "><code class="language-rust" data-lang="rust"><span>sqlx</span><span style="color:#f29e74;">::</span><span>query</span><span style="color:#f29e74;">!</span><span>(</span><span style="color:#bae67e;">&quot;UPDATE todos SET done=true WHERE title=&#39;Learn SQLx&#39;&quot;</span><span>)
</span><span>    </span><span style="color:#f29e74;">.</span><span style="color:#f28779;">execute</span><span>(</span><span style="color:#f29e74;">&amp;</span><span>pool)
</span><span>    </span><span style="color:#f29e74;">.</span><span>await
</span><span>    </span><span style="color:#f29e74;">.</span><span style="color:#f28779;">unwrap</span><span>()</span><span style="color:#ccc9c2cc;">;
</span></code></pre>
<hr />
<h4 id="recommendations"><a class="text-white no-underline transition-none hover:underline"
   href="#recommendations">Recommendations</a></h4>
<ul>
<li><a href="https://youtu.be/cBLZ8jbNtcw">SQL Injection in Rust; still possible? - Security Research</a>: A video about how SQLx prevents SQL injections.</li>
</ul>
<h4 id="code-snippets"><a class="text-white no-underline transition-none hover:underline"
   href="#code-snippets">Code snippets</a></h4>
<p>Almost all code snippets used in this post can be found <a href="https://codeberg.org/mo8it/blog_demos/src/branch/main/sqlx-interacting-with-databases-in-rust">here</a>.</p>

    </article>

    
        <nav class="flex flex-col gap-y-3 mt-8">
            
    
    <a class="py-1.5 px-3 my-2 no-underline bg-gray-800 rounded-xl transition duration-500 hover:scale-[1.02]"
       href="https://salif.github.io/zola-themes-collection/demo/mo8it/blog/sqlx-integration-in-axum/">Next post: SQLx integration in Axum<hr class="mt-1 mb-3 rounded-none border-gray-600"><span class="text-white">How to integrate SQLx in an Axum backend to interact with a database</span></a>


            
    
    <a class="py-1.5 px-3 my-2 no-underline bg-gray-800 rounded-xl transition duration-500 hover:scale-[1.02]"
       href="https://salif.github.io/zola-themes-collection/demo/mo8it/blog/containerized-postgresql-with-rootless-podman/">Previous post: Containerized PostgreSQL with rootless Podman<hr class="mt-1 mb-3 rounded-none border-gray-600"><span class="text-white">How to run rootless Podman containers with PostgreSQL as a central example</span></a>


        </nav>
    

    <section class="mt-8 text-base text-center">
        <p>
            You can suggest improvements on the <a href="https://codeberg.org/mo8it/website/src/branch/main/content/blog">website's repository</a>
        </p>
        <p>
            Content license: <a href="https://creativecommons.org/licenses/by-nc-sa/4.0">CC BY-NC-SA 4.0</a>
        </p>
    </section>

        </main>

        <footer class="pt-2 pb-3 mt-auto">
            <img class="m-0 mx-auto w-20 h-20"
                 src="https://salif.github.io/zola-themes-collection/demo/mo8it/images/happy_ferris.svg"
                 alt="">

            <nav class="flex flex-col gap-y-3 justify-around py-3 text-center bg-gray-800 rounded sm:flex-row sm:rounded-full">
                
                    <a class="text-sm no-underline" href="/contact">Contact</a>
                
                    <a class="text-sm no-underline" href="https://codeberg.org/mo8it/website">Source Code</a>
                
                    <a class="text-sm no-underline" href="/legal-notice">Legal Notice</a>
                
                    <a class="text-sm no-underline" href="/privacy-policy">Privacy Policy</a>
                
            </nav>
        </footer>

        
            <script type="module" src="https://oxitraffic.mo8it.com/count.js"></script>
        
    </body>
</html>
